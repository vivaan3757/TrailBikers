{"ast":null,"code":"import { validateFieldsNatively as r, toNestErrors as e } from \"@hookform/resolvers\";\nimport { appendErrors as o } from \"react-hook-form\";\nfunction n(r, e) {\n  for (var n = {}; r.length;) {\n    var s = r[0],\n      t = s.code,\n      i = s.message,\n      a = s.path.join(\".\");\n    if (!n[a]) if (\"unionErrors\" in s) {\n      var u = s.unionErrors[0].errors[0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: t\n    };\n    if (\"unionErrors\" in s && s.unionErrors.forEach(function (e) {\n      return e.errors.forEach(function (e) {\n        return r.push(e);\n      });\n    }), e) {\n      var c = n[a].types,\n        f = c && c[s.code];\n      n[a] = o(a, e, n, t, f ? [].concat(f, s.message) : s.message);\n    }\n    r.shift();\n  }\n  return n;\n}\nfunction s(o, s, t) {\n  return void 0 === t && (t = {}), function (i, a, u) {\n    try {\n      return Promise.resolve(function (e, n) {\n        try {\n          var a = Promise.resolve(o[\"sync\" === t.mode ? \"parse\" : \"parseAsync\"](i, s)).then(function (e) {\n            return u.shouldUseNativeValidation && r({}, u), {\n              errors: {},\n              values: t.raw ? Object.assign({}, i) : e\n            };\n          });\n        } catch (r) {\n          return n(r);\n        }\n        return a && a.then ? a.then(void 0, n) : a;\n      }(0, function (r) {\n        if (function (r) {\n          return Array.isArray(null == r ? void 0 : r.errors);\n        }(r)) return {\n          values: {},\n          errors: e(n(r.errors, !u.shouldUseNativeValidation && \"all\" === u.criteriaMode), u)\n        };\n        throw r;\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\nexport { s as zodResolver };","map":{"version":3,"names":["n","r","e","length","s","t","code","i","message","a","path","join","u","unionErrors","errors","type","forEach","push","c","types","f","o","concat","shift","Promise","resolve","mode","then","shouldUseNativeValidation","values","raw","Object","assign","Array","isArray","criteriaMode","reject","zodResolver"],"sources":["D:\\TrailRiders\\TrailRiders\\node_modules\\@hookform\\resolvers\\zod\\src\\zod.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Resolver,\n  appendErrors,\n} from 'react-hook-form';\nimport { ZodError, z } from 'zod';\n\nconst isZodError = (error: any): error is ZodError =>\n  Array.isArray(error?.errors);\n\nfunction parseErrorSchema(\n  zodErrors: z.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\n/**\n * Creates a resolver function for react-hook-form that validates form data using a Zod schema\n * @param {z.ZodSchema<TFieldValues>} schema - The Zod schema used to validate the form data\n * @param {Partial<z.ParseParams>} [schemaOptions] - Optional configuration options for Zod parsing\n * @param {Object} [resolverOptions] - Optional resolver-specific configuration\n * @param {('async'|'sync')} [resolverOptions.mode='async'] - Validation mode. Use 'sync' for synchronous validation\n * @param {boolean} [resolverOptions.raw=false] - If true, returns the raw form values instead of the parsed data\n * @returns {Resolver<z.infer<typeof schema>>} A resolver function compatible with react-hook-form\n * @throws {Error} Throws if validation fails with a non-Zod error\n * @example\n * const schema = z.object({\n *   name: z.string().min(2),\n *   age: z.number().min(18)\n * });\n *\n * useForm({\n *   resolver: zodResolver(schema)\n * });\n */\nexport function zodResolver<TFieldValues extends FieldValues>(\n  schema: z.ZodSchema<TFieldValues, any, any>,\n  schemaOptions?: Partial<z.ParseParams>,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw?: boolean;\n  } = {},\n): Resolver<z.infer<typeof schema>> {\n  return async (values, _, options) => {\n    try {\n      const data = await schema[\n        resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n      ](values, schemaOptions);\n\n      options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n      return {\n        errors: {} as FieldErrors,\n        values: resolverOptions.raw ? Object.assign({}, values) : data,\n      };\n    } catch (error: any) {\n      if (isZodError(error)) {\n        return {\n          values: {},\n          errors: toNestErrors(\n            parseErrorSchema(\n              error.errors,\n              !options.shouldUseNativeValidation &&\n                options.criteriaMode === 'all',\n            ),\n            options,\n          ),\n        };\n      }\n\n      throw error;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}